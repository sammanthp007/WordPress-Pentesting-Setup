Done by Samman Bikram Thapa.

# Week 7 Lab: WordPress Pentesting Setup

## Install Docker
Start by getting docker installed and running.

Docker has solid support for most major platforms, and you can follow their published instructions for downloading and installing on Mac or Windows. Additionally, you'll need to install docker-compose, a tool that lets us assemble designs based on multiple docker machines.

Tip: For arch linux, also add the user to docker group using ```gpasswd -a <user> docker```

Once installed, you'll typically need to start docker through its UI tool. But make sure docker is running & accessible from the command line:
```
docker ps
```

## Running WordPress with Docker
To get started quickly, we'll use ``` docker-compose ``` to spin up a typical WP setup, using two containers: one for WP fronted by Apache, and another for the MySQL data store.

Create a new directory on your local machine for this lab. Any location under your user dir is appropriate .In that directory, create two new files, docker-compose.yml and .env:

Create ``` docker-compose.yml ``` with the following contents:
```
version: '2'

services:
   db:
     image: mysql:5.7
     volumes:
       - db_data:/var/lib/mysql
     restart: always
     environment:
       MYSQL_ROOT_PASSWORD: wordpress
       MYSQL_DATABASE: wordpress
       MYSQL_USER: wordpress
       MYSQL_PASSWORD: wordpress

   wordpress:
     depends_on:
       - db
     image: wordpress:${WP_IMAGE_VERSION}
     ports:
       - "8000:80"
     restart: always
     environment:
       WORDPRESS_DB_HOST: db:3306
       WORDPRESS_DB_PASSWORD: wordpress
volumes:
    db_data:
```
Create ```.env``` with:
```
COMPOSE_PROJECT_NAME=wp
WP_IMAGE_VERSION=latest
```
Now you should be able to launch the instance by running the following from the same directory:
```
$ docker-compose up -d
```
This will create a docker container using the latest published WordPress image, and should take approximately 5 - 10 minutes depending on connection speed.

> In Docker, an **image** is a filesystem and associated set of runtime parameters. It doesnâ€™t have state and never changes. A container is a running instance of an image. Learn more here.

Test that you can access the instance (note you may need to wait a minute or so after ```docker-compose up -d``` completes for the WordPress application to load): http://localhost:8000/

If all goes well, you should be prompted to pick a title, language, and administrator login for your new blog. Note a secure password is generated by default --- you'll need to keep track of that.

## Running Kali with Docker
So far, we've been using our host OS browser to setup and use WordPress, which we can do since we mapped port 80 on our WordPress container to port 8000 on localhost. While this is convenient and a good way to explore our WordPress instance, in order to take advantage of the some more advanced penetration testing tools, we can run Kali Linux in a separate docker container.

Before we do that, though, let's take a closer look at what we have so far. The ```docker ps``` command lets you view all running containers:
```
$ docker ps
CONTAINER ID        IMAGE                         COMMAND                  CREATED             STATUS              PORTS                  NAMES
02750f26cca1        wordpress:latest              "docker-entrypoint..."   About an hour ago   Up About an hour    0.0.0.0:8000->80/tcp   wp_wordpress_1
b3783a16a488        mysql:5.7                     "docker-entrypoint..."   About an hour ago   Up About an hour    3306/tcp               wp_db_1
```

You can see the MySQL and WP containers; note there's a unique ```CONTAINER ID``` and also a friendlier ```NAME``` for each. The name of the WP instance in this case is ```wp_wordpress_1```.

Now, create the Kali container. Since the setup is fairly straightforward, we can skip using ```docker-compose``` and just pull the public image directly and run it. 
Using the ```--network="host"``` flag allows the Kali container to share the same network configuration as the host, so [localhost:8000](http://localhost:8000) will also be accessible from inside the Kali container. 
This is simpler than connecting the Kali container directly to the WP container.
```
$ docker pull kalilinux/kali-linux-docker
$ docker run -itd --name kali --network="host" kalilinux/kali-linux-docker
```
Run ```docker ps``` to verify the new container is up:
```
CONTAINER ID        IMAGE                         COMMAND                  CREATED              STATUS              PORTS                  NAMES
8e6f9c56e846        kalilinux/kali-linux-docker   "/bin/bash"              About a minute ago   Up About a minute                          kali
02750f26cca1        wordpress:latest              "docker-entrypoint..."   About an hour ago    Up About an hour    0.0.0.0:8000->80/tcp   wp_wordpress_1
b3783a16a488        mysql:5.7                     "docker-entrypoint..."   About an hour ago    Up About an hour    3306/tcp               wp_db_1```
No ports are exposed because we'll need to use bash directly from the Kali container. We can access our Kali bash shell using ```docker exec```:
```
$ docker exec -it kali bash
root@8e6f9c56e846:/#
```
Notice the shell prompt changed and includes the docker container id. Notice also that the default user is root, because Kali is all about living dangerously.

To make sure the networking is configured properly, try to access the WordPress blog via localhost:8000 from the Kali container running wget; use the command below to pipe the output to sed, which should extract just the page title:
```
$ wget --quiet -O - http://localhost:8000/ | sed -n -e 's!.*<title>\(.*\)</title>.*!\1!p'
Test &#8211; Just another WordPress site
```
## Tooling Up Kali
Unlike the Kali ISO, which comes with more tools than we can possibly use or cover here, the public Kali docker image comes with only the base OS. The tools can be installed individually or in batch using Kali's metapackages. Start by updating the apt cache and searching for the available metapackages:
```
$ apt-get update && apt-cache search kali-linux
```
You should see the metapackages listed in the output. For now, let's just install kali-linux-web, which includes all the web penetration testing tools:
```
$ apt-get install kali-linux-web
```
This command may take quite some time (~ 45 mins) to complete, so while you're waiting, you can move on to the next few challenges using WordPress.

> The next challenges should be completed on your host machine, not in the Kali container. You'll need to get used to switching between the two. You either leave the Kali container shell up in your terminal and just open a new terminal window to complete work in your host OS (recommended), or, if you prefer, you can close the Kali container shell with the exit command to go back to your host, but then you'll need to reconnect to it later via the docker exec -it kali bash command.

## WordPress Basics
As you might imagine, due to its popularity among both users and attackers, WordPress is a very mature product by this point in its evolution, and there's a lot to know about it. We won't be able to cover it in great depth, but there are certainly some basics you should get familiar with before proceeding.

> WP is very extensible via plugins and themes, most of which are developed by third parties. In the steps below, we'll make a distinction between Core WP, which refers to the WP base functionality, and basically everything else: plugins, themes, and other optional extensions. While these extensions are often the most vulnerable parts of a WP site, vulnerabilities in the core codebase are of greater importance --- but also more difficult to find.
Make sure you are able to perform the following tasks (use the browser on your host machine):

1. Create a post
2. Create a page
3. Create an attachment
4. Delete and undelete a post/page
5. Register users and assign roles
6. Change the theme
7. Install a plugin

## Looking Under the Hood
It's one thing to understand using WP through its UI, but in order to probe the application for security issues, we really need to understand how it works, which means looking at the source code. WP has a very large codebase, and digesting all of it would require a lot of time. But we're not looking to cultivate the kind of familiarity with the source that a full-time WP developer would possess --- the goal is to apply analytical skills in a way that's more surgical than comprehensive. And this is a skill that's common among both hackers and security engineers: the ability to dig deep into large, unfamiliar codebases (sometimes even in unfamiliar languages) with very focused objectives.

For this milestone, you should identify the PHP entry points in the source code for each of the core WP functions you performed in the previous milestone.
For example, for the [About Page](http://localhost:8000/wp-admin/about.php) in the WordPress admin section, the source PHP is [found here](https://core.trac.wordpress.org/browser/trunk/src/wp-admin/about.php). You should be able to identify the primary PHP source for creating a post, page, user, etc. But keep in mind, the goal here is not just to identify the source for a specific set of functions; the real goal is to build this skill of testing, code reading, and focused investigation.

Resources:

[WordPress Source Browser](https://core.trac.wordpress.org/browser/)
[WordPress Developer Reference](https://developer.wordpress.org/reference/)
## Casing the Joint
Back in your Kali container (reconnect using ```docker exec -it kali bash``` if you exited earlier), hopefully Kali has finished installing kali-linux-web. 
The first tool we'll use in our Kali container is ```wpscan```, a black box vulnerability scanner for WordPress. Usage is straightforward: just pass ```wpscan``` a URL and it will list all the information it can determine about the WP instance at that URL, including the version of WP, any known vulnerabilities with that version, any plugins/themes installed and vulnerabilities with those, and a whole lot more.

First thing to do is update the ```wpscan``` database with the latest vulnerability information:
```
$ wpscan --update
```
Now, run ```wpscan``` against our WP instance at ```localhost:8000```:
```
$ wpscan --url http://localhost:8000/
```
Reviewing the output, you can see wpscan was able to correctly identify the WP version we're running and report on some miscellaneous issues...but not a whole lot more. This is because the latest version of WP should have no public vulnerabilities --- any zero-days that are announced should be quickly patched. We're also not running many plugins, so the attack surface will be limited to core WP. To increase that attack surface, we'll need to modify our WP container.

## WordPress Time Machine
Finding vulnerabilities in the latest version of WP will be quite difficult. This is part of what a professional security researcher (or a hacker) would do, and it can take a lot of time and advanced skills, as most of the low-hanging fruit has been discovered and patched already. In order to start building those skills, it's helpful to look at some documented and patched vulnerabilities in older versions of WP that we can exploit, following in the footsteps of those who came before.

Fortunately, WordPress has a richly-documented release history and archive. We'll need to update our WP docker composition to load one of these versions; generally, the older the version the greater the number of known issues.

For this exercise, we'll go back two years in time to WordPress 4.2. Switch back to your host OS and start by pulling the 4.2 docker image:
```
$ docker pull wordpress:4.2.2
```
Next, back on your host machine, update the ```.env``` file from milestone #2 to point to the new version (```WP_IMAGE_VERSION=4.2.2```) and from that same directory, stop, remove, and recreate the WP containers:
```
$ docker-compose stop && docker-compose rm -f
# Stopping wp_wordpress_1 ... done
# Stopping wp_db_1 ... done
# Going to remove wp_wordpress_1, wp_db_1
# Removing wp_wordpress_1 ... done
# Removing wp_db_1 ... done
$ docker volume rm wp_db_data
# wp_db_data
$ docker-compose up -d --force-recreate
# Creating volume "wp_db_data" with default driver
# Creating wp_db_1
# Creating wp_wordpress_1
```
Give it a minute or so once these commands complete, then load [http://localhost:8000] in your browser. You should see the WordPress setup screen prompting you to pick a language. The screen following that will, look familiar, too...but do you notice anything different? Unlike the newer version, the admin password isn't generated by default. This should tell you a lot about the history of WP hacking.

Once you complete the setup and login, you should see a banner at the top left asking you to update WordPress (don't do it). Instead of setting up additional users and pages at this point, let's see what we can find out about this older version out of the box. Note: you do need to complete the basic setup, though -- localhost:8000 needs to be showing the blog.

## wpscan vs. WP 4.2
Back in your Kali container, run exactly the same command as before: wpscan --url http://localhost:8000/. There should be a lot more output this time. A list of known vulnerabilities will be printed, each with reference links. Most of the links will be pro forma announcements, but some will contain details about how to exploit the vulnerability. For example:
```
[!] Title: WordPress 2.5-4.6 - Authenticated Stored Cross-Site Scripting via Image Filename
    Reference: https://wpvulndb.com/vulnerabilities/8615
    Reference: https://wordpress.org/news/2016/09/wordpress-4-6-1-security-and-maintenance-release/
    Reference: https://github.com/WordPress/WordPress/commit/c9e60dab176635d4bfaaf431c0ea891e4726d6e0
    Reference: https://sumofpwn.nl/advisory/2016/persistent_cross_site_scripting_vulnerability_in_wordpress_due_to_unsafe_processing_of_file_names.html
    Reference: http://seclists.org/fulldisclosure/2016/Sep/6
    Reference: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-7168
[i] Fixed in: 4.2.10
```
One of the above links is not like the others --- it contains helpful information not just about the nature of the vulnerability but an explanation of the exploit. The object of this challenge is to recreate the above exploit. You should be able to demonstrate XSS via the classic proof-of-concept: a javascript alert.
